package config

import (
	"bytes"
	"strings"
	"testing"
	"text/template"
	"time"

	"github.com/InditexTech/gh-sherpa/internal/domain/issue_types"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMetedataTemplateConfiguration(t *testing.T) {
	tmpl, err := template.ParseFS(embeddedTemplates, "templates/*.tmpl")
	require.NoError(t, err)

	t.Run("Should render metadata", func(t *testing.T) {
		var buff bytes.Buffer
		templateCfg := configFileTemplateData{
			Metadata: MetadataConfiguration{
				Version:     "1.0.0",
				GeneratedAt: time.Date(2023, 10, 2, 17, 30, 0, 0, time.UTC),
			},
		}
		err := tmpl.ExecuteTemplate(&buff, "configuration", templateCfg)
		require.NoError(t, err)
		assert.True(t, strings.Contains(buff.String(), "# This file was generated by GH Sherpa CLI v1.0.0 at 2023-10-02 17:30:00 +0000 UTC"))
	})
}

func TestJiraTemplateConfiguration(t *testing.T) {
	tmpl, err := template.ParseFS(embeddedTemplates, "templates/*.tmpl")
	require.NoError(t, err)

	t.Run("Should generate empty configuration", func(t *testing.T) {
		jiraData := JiraTemplateConfiguration{
			Jira: Jira{},
		}

		var buff bytes.Buffer
		err := tmpl.ExecuteTemplate(&buff, "jiraConfiguration", jiraData)
		require.NoError(t, err)

		require.Equal(t, `# Jira configuration -----------------------------------#
jira:
  # Jira authentication configuration
  auth:
    # Jira authentication url to generate PAT
    # WARNING: Replace it with your actual Jira authentication url
    host: 
    # Jira already generated PAT
    # WARNING: Replace it with your actual Jira PAT
    token: 
    # Jira insecure TLS configuration
    skip_tls_verify: false
  # Jira issue types configuration
  issue_types: {}
`, buff.String())
	})

	t.Run("Should generate configuration with values", func(t *testing.T) {
		jiraData := JiraTemplateConfiguration{
			Jira: Jira{
				Auth: JiraAuth{
					Host:        "https://jira.example.com",
					Token:       "jira-pat",
					InsecureTLS: true,
				},
				IssueTypes: map[issue_types.IssueType][]string{
					issue_types.Bug:         {"1"},
					issue_types.Feature:     {"2", "3", "4"},
					issue_types.Improvement: {},
				},
			},
		}

		var buff bytes.Buffer
		err := tmpl.ExecuteTemplate(&buff, "jiraConfiguration", jiraData)
		require.NoError(t, err)

		require.Equal(t, `# Jira configuration -----------------------------------#
jira:
  # Jira authentication configuration
  auth:
    # Jira authentication url to generate PAT
    # WARNING: Replace it with your actual Jira authentication url
    host: https://jira.example.com
    # Jira already generated PAT
    # WARNING: Replace it with your actual Jira PAT
    token: jira-pat
    # Jira insecure TLS configuration
    skip_tls_verify: true
  # Jira issue types configuration
  issue_types:
    bug: ["1"]
    feature: ["2", "3", "4"]
    improvement: []
`, buff.String())

	})
}

func TestGithubTemplateConfiguration(t *testing.T) {
	tmpl, err := template.ParseFS(embeddedTemplates, "templates/*.tmpl")
	require.NoError(t, err)

	t.Run("Should generate empty configuration", func(t *testing.T) {
		githubData := GithubTemplateConfiguration{
			Github: Github{},
		}

		var buff bytes.Buffer
		err := tmpl.ExecuteTemplate(&buff, "githubConfiguration", githubData)
		require.NoError(t, err)

		require.Equal(t, `# Github configuration --------------------------------#
github:
  # Github issue labels configuration
  issue_labels: {}
`, buff.String())
	})

	t.Run("Should generate configuration with values", func(t *testing.T) {
		githubData := GithubTemplateConfiguration{
			Github: Github{
				IssueLabels: map[issue_types.IssueType][]string{
					issue_types.Bugfix:        {"kind/bug", "kind/bugfix"},
					issue_types.Feature:       {"kind/feature"},
					issue_types.Refactoring:   {"kind/refactoring"},
					issue_types.Documentation: {},
				},
			},
		}

		var buff bytes.Buffer
		err := tmpl.ExecuteTemplate(&buff, "githubConfiguration", githubData)
		require.NoError(t, err)

		require.Equal(t, `# Github configuration --------------------------------#
github:
  # Github issue labels configuration
  issue_labels:
    bugfix: ["kind/bug", "kind/bugfix"]
    documentation: []
    feature: ["kind/feature"]
    refactoring: ["kind/refactoring"]
`, buff.String())
	})
}

func TestBranchesTemplateConfiguration(t *testing.T) {
	tmpl, err := template.ParseFS(embeddedTemplates, "templates/*.tmpl")
	require.NoError(t, err)

	t.Run("Should generate empty configuration", func(t *testing.T) {
		branchesData := BranchesTemplateConfiguration{
			Branches: Branches{},
		}

		var buff bytes.Buffer
		err := tmpl.ExecuteTemplate(&buff, "branchesConfiguration", branchesData)
		require.NoError(t, err)

		require.Equal(t, `# Branches configuration ------------------------------#
branches:
  # Branch prefix configuration
  prefixes: {}
`, buff.String())
	})

	t.Run("Should generate configuration with values", func(t *testing.T) {
		branchesData := BranchesTemplateConfiguration{
			Branches: Branches{
				Prefixes: map[issue_types.IssueType]string{
					issue_types.Bug:         "fix",
					issue_types.Feature:     "feat",
					issue_types.Improvement: "",
				},
			},
		}

		var buff bytes.Buffer
		err := tmpl.ExecuteTemplate(&buff, "branchesConfiguration", branchesData)
		require.NoError(t, err)

		require.Equal(t, `# Branches configuration ------------------------------#
branches:
  # Branch prefix configuration
  prefixes:
    bug: fix
    feature: feat
    improvement: 
`, buff.String())
	})

}
